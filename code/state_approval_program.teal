// CODE NOT WORKING YET - WORK IN PROGRESS - IN GIT ONLY FOR SAFETY

// scratch
// 10 - loop ix
// 11 - ApplicationArgs ix
// 12 - ASA id
// 13 - ASA w
// 14 - sum w
// 15 - n
// 16 - ni

#pragma version 6

txn OnCompletion
int NoOp
==
bnz handle_noop

txn OnCompletion
int OptIn
==
bnz handle_optin

txn OnCompletion
int CloseOut
==
bnz handle_closeout

txn OnCompletion
int UpdateApplication
==
bnz handle_updateapp

txn OnCompletion
int DeleteApplication
==
bnz handle_deleteapp

// Unexpected OnCompletion value. Should be unreachable.
b decline
////////////////


////////////////
handle_noop:

txna ApplicationArgs 0
byte "update"
==
bnz handle_update

txna ApplicationArgs 0
byte "swap"
==
bnz handle_swap

txna ApplicationArgs 0
byte "withdraw"
==
bnz handle_withdraw

txna ApplicationArgs 0
byte "optin"
==
bnz handle_optin_asa

// Unexpected first arg
b decline
////////////////




///////////////
// swap
// args: swap coin_o
// group of 2: 1st send A_i amount of coin i / 2nd app call here to trigger txn to send A_o of coin o to sender
// 
handle_swap:

// 2 txns in group
// global GroupSize
// int 2
// ==
// assert

// // this txn is 2nd txn in group
// txn GroupIndex
// int 1
// ==
// assert

// // ASA id
// int 0
// gtxns XferAsset
// store 12

// // balance of coin_i
// load 12
// bz sc_balance_algo

// // int 1 // acc 1 is SC account
// // int ASA_ID // ASA id
// // asset_holding_get AssetBalance // stack, balance, opted-in

// // assert that we are opted into coin_i
// int 1
// ==
// assert

// store 0 // balance of coin_i

// // balance of coin_o
// int 1 // acc 1 is SC account
// txna ApplicationArgs 1 // coin_o ASA id
// asset_holding_get AssetBalance // stack, balance, opted-in

// // assert that we are opted into coin_o
// int 1
// ==
// assert

// store 1 // balance of coin_o

// // weight of coin_i
// int 0
// gtxns XferAsset
// app_global_get_ex // stack, weight, key exists

// // assert that we have weight for this ASA
// int 1
// ==
// assert

// store 2 // weight coin_i

// // weight of coin_o
// int 0
// txna ApplicationArgs 1 // coin_o ASA id
// app_global_get_ex // stack, weight, key exists

// // assert that we have weight for this ASA
// int 1
// ==
// assert

// store 3 // weight coin_o

// // coin_i amount - TODO ALGO case - TODO remove swap fee
// int 0
// gtxns AssetAmount
// store 4

// // calc coin_o amount
// int 1
// load 0
// load 4
// +
// load 0
// /
// load 2
// load 3
// /
// exp
// -
// load 1
// *

// TODO send coin_o

b approve
///////////////






////////////////
// withdraw coins from SC to creator
// only creator
handle_withdraw:
b decline
////////////////


////////////////
get_n:
int 0
byte "n"
app_global_get_ex
pop
retsub
////////////////

////////////////
delete_global_state:

// loop ix
int 0
store 10

// n
callsub get_n
store 15

// n == 0 && retsub
load 15
bz delete_global_state_loop_end

// del n
byte "n"
app_global_del

delete_global_state_loop:

// ni
byte "n"
load 10
itob
extract 7 1
concat
store 16

// ASA id
load 16
app_global_get
store 12

// del global[ni]
load 16
app_global_del

// del global[ASA id]
load 12
app_global_del

// loop
load 10
int 1
+
load 15
<
bz delete_global_state_loop_end
load 10
int 1
+
store 10
b delete_global_state_loop

delete_global_state_loop_end:
retsub
////////////////





///////////////
// update
// only creator can update
// args: update ASA_1 w_1 ASA_2 w_2 ...
// delete all existing state
// global[ASA_i] = w_i
// global[n] = NumAppArgs
// assert sum w_i == 1
// if global[ASA_i] does not exist yet, set global[ASA_i] = w_i if global state space available
handle_update:

// only creator 
global CreatorAddress
txn Sender
==
assert

// only 1 txn in group
global GroupSize
int 1
==
assert

// delete old state
callsub delete_global_state

// set n
byte "n"
txn NumAppArgs
int 1
-
int 2
/
app_global_put

// loop through all args to update global state

// sum w_i
int 0
store 14

// loop ix
int 0
store 10

handle_update_loop:

// loop ix -> ApplicationArgs ix
load 10
int 2
*
int 1
+
store 11

// ASA id
load 11
txnas ApplicationArgs
store 12

// w
load 11
int 1
+
txnas ApplicationArgs
btoi
store 13

// sum w
load 13
load 14
+
store 14

// set global[ASA id] = w
load 12
load 13
app_global_put

// set global[ni] = ASA id
byte "n"
load 10
itob
extract 7 1
concat
load 12
app_global_put

// loop
load 11
int 2
+
txn NumAppArgs
<
bz handle_update_loop_end
load 10
int 1
+
store 10
b handle_update_loop

handle_update_loop_end:

// check sum w
load 14
int 10000
==
assert

// done
b approve
///////////////

///////////////
// optin SC to ASA
handle_optin_asa:

global CreatorAddress
txn Sender
==
assert

global GroupSize
int 1
==
assert

itxn_begin
int axfer
itxn_field TypeEnum
global CurrentApplicationAddress
itxn_field AssetReceiver
int 0
itxn_field AssetAmount
txn Assets 0
itxn_field XferAsset
itxn_submit

b approve
///////////////



///////////////
// Update only by creator - for now
// TODO maybe make updating impossible for safety and assurance
handle_updateapp:
handle_deleteapp:
global GroupSize
int 1
==
assert

global CreatorAddress
txn Sender
==
assert

b approve
///////////////

///////////////
// handle closeOut, cannot delete app, no decline
handle_closeout:
b decline
///////////////

///////////////
handle_optin:
b approve
///////////////

////////////////
// end branches
decline:
int 0
return

approve:
int 1
return
////////////////
